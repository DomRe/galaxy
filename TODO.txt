SUPERCLUSTER:
- physics tools
- export to json / save as json
- documentation
- VFS mount/unmount
- Use EACH() in supercluster for entity_ui.
- two states ("game") and ("editor")
- play button switches between them.
- serialzie data when swtiching, then load and run game state.
- tilemap editor
	- see stb tilemap on utube for ideas
- Integrate openal context with dev tools.
- serialization
- audio support
- gui builder

RESTRUCTURE:
Composition > Inheritance
Each Module Shall Have (if needed):
- Lua Interface
- JSON Interface
- Serialization Interface
- Seperate methods and members into their own public/private/etc in classes
- Proper use of 'noexcept', 'static', and 'multithreading'.
- Attributes
- Const/Constexpr
- Use VFS
- Parallell Execution
- Put deleted into private.
- Header orders
- call base move opoerators
- Restore data-driven design
- Engine needs to be cohesive.
- write tests
- dynamic_cast -> static_cast

TODO:
- fix camera scrolling. lock at 0.1.
- Dependencies should only abstract away system specific implementations.
- Docs error fix after this.
- Loading state support?


CMAKE:
Run Clang-Tidy
Run Clang-Format
Run Include-What-You-Use
MSVC code analysis
https://www.google.com/search?client=firefox-b-d&q=cmake+run+clang-tidy+on+build
https://www.google.com/search?client=firefox-b-d&q=cmake+run+clang-format+on+build
https://gernotklingler.com/blog/open-source-tools-examine-and-adjust-include-dependencies/
https://www.fluentcpp.com/2021/01/01/include-what-you-use/

		/*
		if (animation != nullptr)
		{
			ImGui::Spacing();
			ImGui::Separator();
			ImGui::Text("Animation Component");

			ImGui::Spacing();
			ImGui::Spacing();

			auto region       = animation->get_region();
			m_batch_region[0] = region.m_x;
			m_batch_region[1] = region.m_y;
			m_batch_region[2] = region.m_width;
			m_batch_region[3] = region.m_height;
			if (ImGui::InputScalarN("Region", ImGuiDataType_Float, &m_batch_region, 4))
			{
				animation->update_region(m_batch_region[0], m_batch_region[1], m_batch_region[2], m_batch_region[3]);
			}

			int z = static_cast<int>(animation->z_level());
			if (ImGui::InputInt("Z-Level", &z, 1, 2, ImGuiInputTextFlags_AutoSelectAll | ImGuiInputTextFlags_EnterReturnsTrue))
			{
				animation->set_z_level(z);
			}

			float opacity = animation->opacity();
			if (ImGui::SliderFloat("Opacity", &opacity, 0.0f, 1.0f))
			{
				animation->set_opacity(opacity);
			}

			if (ImGui::Button("Add Animation"))
			{
				m_add_anim_popup = !m_add_anim_popup;
			}

			if (m_add_anim_popup)
			{
				static std::string s_id                      = "";
				static bool s_loop                           = false;
				static float s_speed                         = 1.0f;
				static std::vector<graphics::Frame> s_frames = {};

				ImGui::BeginPopup("Add Animation", ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings);

				ImGui::InputText("ID", &s_id, ImGuiInputTextFlags_AutoSelectAll | ImGuiInputTextFlags_CharsNoBlank);
				ImGui::Checkbox("Is Looping?", &s_loop);
				ImGui::SliderFloat("Speed", &s_speed, 0.1f, 10.0f);

				if (ImGui::Button("Add Frame"))
				{
					static float s_xy[2]          = {0.0f, 0.0f};
					static float s_time_per_frame = 1.0f;

					ImGui::BeginPopup("Add Frame", ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings);

					ImGui::InputScalarN("Texture x/y Coords", ImGuiDataType_Float, &s_xy, 2);
					ImGui::SliderFloat("Time Per Frame", &s_time_per_frame, 0.1f, 10.0f);

					if (ImGui::Button("Add"))
					{
						graphics::Frame frame {s_xy[0], s_xy[1], s_time_per_frame};
						s_frames.emplace_back(frame);

						s_xy[0]          = 0.0f;
						s_xy[1]          = 0.0f;
						s_time_per_frame = 1.0f;
						ImGui::CloseCurrentPopup();
					}

					ImGui::EndPopup();
				}

				if (ImGui::Button("Add"))
				{
					if (!s_frames.empty())
					{
						animation->add_animation(s_id, s_id, s_loop, static_cast<double>(s_speed), s_frames);

						s_id    = "";
						s_loop  = false;
						s_speed = 1.0f;
						s_frames.clear();

						ImGui::CloseCurrentPopup();
					}
					else
					{
						ImGui::Text("Cannot add an animation without frames.");
					}
				}

				ImGui::EndPopup();
			}

			if (ImGui::BeginCombo("Select Animation", "..."))
			{
				for (const auto& [name, anim] : animation->get_all_anims())
				{
					const bool selected = (m_active_anim == name);
					if (ImGui::Selectable(name.c_str(), selected))
					{
						m_active_anim = name;
					}

					if (selected)
					{
						ImGui::SetItemDefaultFocus();
					}
				}

				ImGui::EndCombo();
			}

			if (!m_active_anim.empty())
			{
				ImGui::Text(fmt::format("Current Anim: {0}.", m_active_anim).c_str());
			}

			if (ImGui::Button("Play Animation"))
			{
				animation->play();
			}

			if (ImGui::Button("Pause Animation"))
			{
				animation->pause();
			}

			if (ImGui::Button("Stop Animation"))
			{
				animation->stop();
			}

			if (physics == nullptr)
			{
				glm::vec2 pos = animation->get_pos();
				if (ImGui::InputScalarN("Pos", ImGuiDataType_Float, &pos, 2))
				{
					animation->set_pos(pos.x, pos.y);
				}

				float rotation = animation->get_rotation();
				if (ImGui::SliderAngle("Rotate", &rotation))
				{
					animation->rotate(rotation);
				}

				float scale = animation->get_scale();
				if (ImGui::SliderFloat("Scale", &scale, 1, 10))
				{
					animation->scale(scale);
				}
			}
		}

		if (sound != nullptr)
		{
			ImGui::Spacing();
			ImGui::Separator();
			ImGui::Text("Sound Component");

			ImGui::Spacing();
			ImGui::Spacing();

			if (ImGui::Button("Load"))
			{
				auto file = fs::open_file_dialog();
				sound->load(file);
			}

			if (ImGui::Button("Play"))
			{
				sound->play();
			}

			if (ImGui::Button("Pause"))
			{
				sound->pause();
			}

			if (ImGui::Button("Stop"))
			{
				sound->stop();
			}

			if (ImGui::Button("Rewind"))
			{
				sound->rewind();
			}

			if (ImGui::Checkbox("Is Looping?", &m_sfx_loop))
			{
				sound->set_looping(m_sfx_loop);
			}
		}

		if (music != nullptr)
		{
			ImGui::Spacing();
			ImGui::Separator();
			ImGui::Text("Music Component");

			ImGui::Spacing();
			ImGui::Spacing();

			if (ImGui::Button("Load"))
			{
				auto file = fs::open_file_dialog();
				music->load(file);
			}

			if (ImGui::Button("Play"))
			{
				music->play();
			}

			if (ImGui::Button("Pause"))
			{
				music->pause();
			}

			if (ImGui::Button("Stop"))
			{
				music->stop();
			}

			if (ImGui::Button("Rewind"))
			{
				music->rewind();
			}

			if (ImGui::Checkbox("Is Looping?", &m_sfx_loop))
			{
				music->set_looping(m_sfx_loop);
			}
		}

		if (physics != nullptr)
		{
			ImGui::Spacing();
			ImGui::Separator();
			ImGui::Text("Physics Component");

			ImGui::Spacing();
			ImGui::Spacing();

			if (!physics->m_body->is_rigid())
			{
				ImGui::Text("Body: Kinetic.");

				static float s_hf = 0.0f;
				if (ImGui::InputFloat("Apply Horizontal Force", &s_hf, 0.1, 1, "%.1f", ImGuiInputTextFlags_CharsNoBlank | ImGuiInputTextFlags_AutoSelectAll | ImGuiInputTextFlags_EnterReturnsTrue))
				{
					auto* kin_body = static_cast<physics::KineticBody*>(physics->m_body.get());
					kin_body->apply_horizontal_force(s_hf);
					s_hf = 0.0f;
				}

				ImGui::SameLine();

				static float s_vf = 0.0f;
				if (ImGui::InputFloat("Apply Vertical Force", &s_vf, 0.1, 1, "%.1f", ImGuiInputTextFlags_CharsNoBlank | ImGuiInputTextFlags_AutoSelectAll | ImGuiInputTextFlags_EnterReturnsTrue))
				{
					auto* kin_body = static_cast<physics::KineticBody*>(physics->m_body.get());
					kin_body->apply_vertical_force(s_vf);
					s_vf = 0.0f;
				}
			}
			else
			{
				ImGui::Text("Body: Static.");
			}

			ImGui::Spacing();

			ImGui::SliderFloat("Restitution", &physics->m_body->m_restitution, 0.0f, 10.0f, "%.1f", ImGuiSliderFlags_AlwaysClamp);

			ImGui::Spacing();

			ImGui::SliderFloat("Dynamic Friction", &physics->m_body->m_dynamic_friction, 0.0f, 20.0f, "%.1f", ImGuiSliderFlags_AlwaysClamp);
			ImGui::SameLine();
			ImGui::SliderFloat("Static Friction", &physics->m_body->m_static_friction, 0.0f, 20.0f, "%.1f", ImGuiSliderFlags_AlwaysClamp);

			ImGui::Spacing();

			ImGui::Text(fmt::format("X Pos: {0}", physics->m_body->get_pos().x).c_str());
			ImGui::SameLine();
			ImGui::Text(fmt::format("Y Pos: {0}", physics->m_body->get_pos().y).c_str());

			ImGui::Spacing();

			ImGui::Text(fmt::format("X Velocity: {0}", physics->m_body->get_vel().x).c_str());
			ImGui::SameLine();
			ImGui::Text(fmt::format("Y Velocity: {0}", physics->m_body->get_vel().y).c_str());

			ImGui::Spacing();

			ImGui::Text(fmt::format("Body Mass: {0}", physics->m_body->mass()).c_str());
		}*/